## 不可重入函数

　这种情况出现在多任务系统当中，在任务执行期间捕捉到信号并对其进行处理时，进程正在执行的指令序列就被信号处理程序临时中断。如果从信号处理程序返回，则继续执行进程断点处的正常指令序列，从重新恢复到断点重新执行的过程中，函数所依赖的环境没有发生改变，就说这个函数是可重入的，反之就是不可重入的


(1)使用了静态[数据结构](http://lib.csdn.net/base/datastructure);
(2)调用了malloc或free;
(3)调用了标准I/O函数;标准io库很多实现都以不可重入的方式使用全局数据结构。
(4)进行了浮点运算.许多的处理器/编译器中，浮点一般都是不可重入的 (浮点运算大多使用协处理器或者软件模拟来实现。





### 并发运行

保守的解决方案有以下几个：

1.在处理程序中只使用异步安全的函数，如write，它们可以保证被异步调用时不会引发错误，具体的函数列表看书。

2.进入处理程序时先保存errno,返回时恢复，防止其他进程修改errno。

3.对共享全局数据结构，访问时应先阻塞所有信号。

4.用volatile声明全局变量，如volatile int g;它相当于告诉编译器，不要缓存这个变量，每次访问它时需从内存中读取，当然，由于一般用在全局变量上，所以会和第三条配合使用，即访问时先阻塞所有信号。

- 在信号处理程序中即使调用可重入函数也有问题要注意。作为一个通用的规则，当在信**号处理程序中调用可重入函数时，应当在其前保存errno，并在其后恢复errno**	（因为每个线程只有一个errno变量，信号处理函数可能会修改其值，要了解经常被捕捉到的信号是SIGCHLD，其信号处理程序通常要调用一种wait函数，而各种wait函数都能改变errno)
- 在信号处理程序中保存errno的目的是忽略信号处理函数的错误

### 可重入函数

**可重入函数可以被一个以上的任务调用**，而**不必担心数据被破坏**。可重入函数任何时候都可以被中断，一段时间以后又可以运行，而相应的数据不会丢失。可重入函数或者只使用局部变量，即**保存在CPU寄存器中或堆栈**中；或者使用**全局变量**，则要对全局变量予以保护

