### 虚拟内存

程序所使用的内存地址叫做虚拟内存地址

实际存储在硬件里面的空间地址叫物理内存地址。

**操作系统引入了虚拟内存**，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：****



### 虚拟内存的好处

1. 虚拟内存可以使得进程对运行内存超过物理内存的大小，因为程序符合局部性原理，cpu访问内存的时候会有明显的重复访问，对于经常没有经常被访问的内存，我们可以交换到物理内存之外，比如硬盘上的swap区域。
2. 由于每个进程都有页表，所以每个进程的虚拟内存空间都是相互独立的，进程也没有办法访问其他进程的空间，这就解决了多进程之间地址冲突的问题

#### malloc是如何分配地址

在Linux操作系统中，虚拟地址空间的内部内核空间和用户空间两部分，不同位数的系统，地址范围也不同，比如常见的32位和64位系统，如下所示；

![image-20230504105136787](C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20230504105136787.png)

- `32` 位系统的内核空间占用 `1G`，位于最高处，剩下的 `3G` 是用户空间；
- `64` 位系统的内核空间和用户空间都是 `128T`，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。



进程只有进入用户态时，只能访问用户空间的内存。

只有进入内核态后，才可以访问内核空间的内存。



<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20230504105853478.png" alt="image-20230504105853478" style="zoom:67%;" />

- 代码段：包括二进制可执行代码
- 数据段： 包括已初始化的静态常量和全局变量
- BSS段： 包括未初始化的静态常量和全局变量
- 堆段：包括动态分配内存，从低地址开始向上增长。
- 文件映射段;包括动态库，共享内存等，从低地址开始向上增长。
- 栈段：包括局部变量和函数调用的上下文，栈的大小是固定的，一般未8m。



#### malloc是如何分配内存的

malloc()并不是系统调用，而是C库里的函数，用于动态分配内存。

malloc申请内存，有两种方式向操作系统申请内存：

- 方式一：当申请的内存小于128k,则调用brk()从堆分配内存
- <img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20230504111020297.png" alt="image-20230504111020297" style="zoom:50%;" />
- 方式二：通过mmap()系统调用在**文件映射区域分配内存。**

<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20230504111038808.png" alt="image-20230504111038808" style="zoom:67%;" />



### free释放内存，会归还给操作系统吗？

这是因为与其把这 1 字节释放给操作系统，不如先缓存着放进 malloc 的内存池里，当进程再次申请 1 字节的内存时就可以直接复用，这样速度快了很多。

- malloc 通过 **brk()** 方式申请的内存，free 释放内存的时候，**并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用**；等到进程退出后，才会释放所有的空间
- malloc 通过 **mmap()** 方式申请的内存，free 释放内存的时候，**会把内存归还给操作系统，内存得到真正的释放**。



## 为什么不全部使用mmap来分配内存？

因为**操作系统申请内存，是通过系统调用的，执行系统调用是要进入内核态，然后再返回用户态**，运行态的切换会花费不少时间。

所以**申请内存的操作应该避免频繁的系统调用**，如果都用mmap来分配内存，等于每次都要执行系统调用。

另外，因为mmap分配内存每次释放的时候，都会归还给操作系统，**于是每次mmap分配虚拟地址都是缺页状态的**，然后在第一次访问该虚拟地址的时候，会触发缺页中断，这样会导致cpu消耗过大。

也就是说，**频繁调用mmap分配内存的话，不仅每次都会发生运行态的切换，还会发生缺页中断**

​	malloc分配内存，通过brk申请内存的好处：

brk（）申请内存的时候，由于堆空间是连续的，所以直接预分配大的内存作为内存池，当内存释放的时候，缓存在内存池里面就可以了。等下次申请内存的时候，就直接从内存池中申请即可，而且可能这块内存中的虚拟地址与物理地址的映射还存在，这样减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低CPU的效率。



### 为什么malloc申请内存不全部用brk来申请？

因为brk申请的空间是不会还回去的，如果频繁调用brk申请内存，那么堆内会产生越来越多的不可用的碎片，

#### free()函数只传入一个内存地址，为什么能知道要释放多大的内存？

malloc创建的空间的会多申请16字节，内存的起始比进程的堆空间起始地址多了16字节。

这个多出来的16字节存储了内存块的描述信息，包括内存块的大小。

<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20230504163207616.png" alt="image-20230504163207616" style="zoom: 80%;" />1

当执行free释放内存的时候，free传进来的地址会左移16个字节，然后从这16个字节中分析当前内存块的大小。



